{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useMemo, useEffect } from \"react\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { createPanResponder, getDistanceBetweenTouches, getImageTranslate, getImageDimensionsByTranslate } from \"../utils\";\nvar SCREEN = Dimensions.get(\"window\");\nvar SCREEN_WIDTH = SCREEN.width;\nvar SCREEN_HEIGHT = SCREEN.height;\nvar MIN_DIMENSION = Math.min(SCREEN_WIDTH, SCREEN_HEIGHT);\nvar SCALE_MAX = 2;\nvar DOUBLE_TAP_DELAY = 300;\nvar OUT_BOUND_MULTIPLIER = 0.75;\n\nvar usePanResponder = function usePanResponder(_ref) {\n  var initialScale = _ref.initialScale,\n      initialTranslate = _ref.initialTranslate,\n      onZoom = _ref.onZoom,\n      doubleTapToZoomEnabled = _ref.doubleTapToZoomEnabled,\n      onLongPress = _ref.onLongPress,\n      delayLongPress = _ref.delayLongPress;\n  var numberInitialTouches = 1;\n  var initialTouches = [];\n  var currentScale = initialScale;\n  var currentTranslate = initialTranslate;\n  var tmpScale = 0;\n  var tmpTranslate = null;\n  var isDoubleTapPerformed = false;\n  var lastTapTS = null;\n  var longPressHandlerRef = null;\n  var meaningfulShift = MIN_DIMENSION * 0.01;\n  var scaleValue = new Animated.Value(initialScale);\n  var translateValue = new Animated.ValueXY(initialTranslate);\n  var imageDimensions = getImageDimensionsByTranslate(initialTranslate, SCREEN);\n\n  var getBounds = function getBounds(scale) {\n    var scaledImageDimensions = {\n      width: imageDimensions.width * scale,\n      height: imageDimensions.height * scale\n    };\n    var translateDelta = getImageTranslate(scaledImageDimensions, SCREEN);\n    var left = initialTranslate.x - translateDelta.x;\n    var right = left - (scaledImageDimensions.width - SCREEN.width);\n    var top = initialTranslate.y - translateDelta.y;\n    var bottom = top - (scaledImageDimensions.height - SCREEN.height);\n    return [top, left, bottom, right];\n  };\n\n  var getTranslateInBounds = function getTranslateInBounds(translate, scale) {\n    var inBoundTranslate = {\n      x: translate.x,\n      y: translate.y\n    };\n\n    var _getBounds = getBounds(scale),\n        _getBounds2 = _slicedToArray(_getBounds, 4),\n        topBound = _getBounds2[0],\n        leftBound = _getBounds2[1],\n        bottomBound = _getBounds2[2],\n        rightBound = _getBounds2[3];\n\n    if (translate.x > leftBound) {\n      inBoundTranslate.x = leftBound;\n    } else if (translate.x < rightBound) {\n      inBoundTranslate.x = rightBound;\n    }\n\n    if (translate.y > topBound) {\n      inBoundTranslate.y = topBound;\n    } else if (translate.y < bottomBound) {\n      inBoundTranslate.y = bottomBound;\n    }\n\n    return inBoundTranslate;\n  };\n\n  var fitsScreenByWidth = function fitsScreenByWidth() {\n    return imageDimensions.width * currentScale < SCREEN_WIDTH;\n  };\n\n  var fitsScreenByHeight = function fitsScreenByHeight() {\n    return imageDimensions.height * currentScale < SCREEN_HEIGHT;\n  };\n\n  useEffect(function () {\n    scaleValue.addListener(function (_ref2) {\n      var value = _ref2.value;\n\n      if (typeof onZoom === \"function\") {\n        onZoom(value !== initialScale);\n      }\n    });\n    return function () {\n      return scaleValue.removeAllListeners();\n    };\n  });\n\n  var cancelLongPressHandle = function cancelLongPressHandle() {\n    longPressHandlerRef && clearTimeout(longPressHandlerRef);\n  };\n\n  var handlers = {\n    onGrant: function onGrant(_, gestureState) {\n      numberInitialTouches = gestureState.numberActiveTouches;\n      if (gestureState.numberActiveTouches > 1) return;\n      longPressHandlerRef = setTimeout(onLongPress, delayLongPress);\n    },\n    onStart: function onStart(event, gestureState) {\n      initialTouches = event.nativeEvent.touches;\n      numberInitialTouches = gestureState.numberActiveTouches;\n      if (gestureState.numberActiveTouches > 1) return;\n      var tapTS = Date.now();\n      isDoubleTapPerformed = Boolean(lastTapTS && tapTS - lastTapTS < DOUBLE_TAP_DELAY);\n\n      if (doubleTapToZoomEnabled && isDoubleTapPerformed) {\n        var isScaled = currentTranslate.x !== initialTranslate.x;\n        var _event$nativeEvent$to = event.nativeEvent.touches[0],\n            touchX = _event$nativeEvent$to.pageX,\n            touchY = _event$nativeEvent$to.pageY;\n        var targetScale = SCALE_MAX;\n        var nextScale = isScaled ? initialScale : targetScale;\n        var nextTranslate = isScaled ? initialTranslate : getTranslateInBounds({\n          x: initialTranslate.x + (SCREEN_WIDTH / 2 - touchX) * (targetScale / currentScale),\n          y: initialTranslate.y + (SCREEN_HEIGHT / 2 - touchY) * (targetScale / currentScale)\n        }, targetScale);\n        onZoom(!isScaled);\n        Animated.parallel([Animated.timing(translateValue.x, {\n          toValue: nextTranslate.x,\n          duration: 300,\n          useNativeDriver: true\n        }), Animated.timing(translateValue.y, {\n          toValue: nextTranslate.y,\n          duration: 300,\n          useNativeDriver: true\n        }), Animated.timing(scaleValue, {\n          toValue: nextScale,\n          duration: 300,\n          useNativeDriver: true\n        })], {\n          stopTogether: false\n        }).start(function () {\n          currentScale = nextScale;\n          currentTranslate = nextTranslate;\n        });\n        lastTapTS = null;\n      } else {\n        lastTapTS = Date.now();\n      }\n    },\n    onMove: function onMove(event, gestureState) {\n      var dx = gestureState.dx,\n          dy = gestureState.dy;\n\n      if (Math.abs(dx) >= meaningfulShift || Math.abs(dy) >= meaningfulShift) {\n        cancelLongPressHandle();\n      }\n\n      if (doubleTapToZoomEnabled && isDoubleTapPerformed) {\n        cancelLongPressHandle();\n        return;\n      }\n\n      if (numberInitialTouches === 1 && gestureState.numberActiveTouches === 2) {\n        numberInitialTouches = 2;\n        initialTouches = event.nativeEvent.touches;\n      }\n\n      var isTapGesture = numberInitialTouches == 1 && gestureState.numberActiveTouches === 1;\n      var isPinchGesture = numberInitialTouches === 2 && gestureState.numberActiveTouches === 2;\n\n      if (isPinchGesture) {\n        cancelLongPressHandle();\n        var initialDistance = getDistanceBetweenTouches(initialTouches);\n        var currentDistance = getDistanceBetweenTouches(event.nativeEvent.touches);\n        var nextScale = currentDistance / initialDistance * currentScale;\n\n        if (nextScale < initialScale) {\n          nextScale = nextScale + (initialScale - nextScale) * OUT_BOUND_MULTIPLIER;\n        }\n\n        if (currentScale > initialScale && currentScale > nextScale) {\n          var k = (currentScale - initialScale) / (currentScale - nextScale);\n          var nextTranslateX = nextScale < initialScale ? initialTranslate.x : currentTranslate.x - (currentTranslate.x - initialTranslate.x) / k;\n          var nextTranslateY = nextScale < initialScale ? initialTranslate.y : currentTranslate.y - (currentTranslate.y - initialTranslate.y) / k;\n          translateValue.x.setValue(nextTranslateX);\n          translateValue.y.setValue(nextTranslateY);\n          tmpTranslate = {\n            x: nextTranslateX,\n            y: nextTranslateY\n          };\n        }\n\n        scaleValue.setValue(nextScale);\n        tmpScale = nextScale;\n      }\n\n      if (isTapGesture && currentScale > initialScale) {\n        var _currentTranslate = currentTranslate,\n            x = _currentTranslate.x,\n            y = _currentTranslate.y;\n        var _dx = gestureState.dx,\n            _dy = gestureState.dy;\n\n        var _getBounds3 = getBounds(currentScale),\n            _getBounds4 = _slicedToArray(_getBounds3, 4),\n            topBound = _getBounds4[0],\n            leftBound = _getBounds4[1],\n            bottomBound = _getBounds4[2],\n            rightBound = _getBounds4[3];\n\n        var _nextTranslateX = x + _dx;\n\n        var _nextTranslateY = y + _dy;\n\n        if (_nextTranslateX > leftBound) {\n          _nextTranslateX = _nextTranslateX - (_nextTranslateX - leftBound) * OUT_BOUND_MULTIPLIER;\n        }\n\n        if (_nextTranslateX < rightBound) {\n          _nextTranslateX = _nextTranslateX - (_nextTranslateX - rightBound) * OUT_BOUND_MULTIPLIER;\n        }\n\n        if (_nextTranslateY > topBound) {\n          _nextTranslateY = _nextTranslateY - (_nextTranslateY - topBound) * OUT_BOUND_MULTIPLIER;\n        }\n\n        if (_nextTranslateY < bottomBound) {\n          _nextTranslateY = _nextTranslateY - (_nextTranslateY - bottomBound) * OUT_BOUND_MULTIPLIER;\n        }\n\n        if (fitsScreenByWidth()) {\n          _nextTranslateX = x;\n        }\n\n        if (fitsScreenByHeight()) {\n          _nextTranslateY = y;\n        }\n\n        translateValue.x.setValue(_nextTranslateX);\n        translateValue.y.setValue(_nextTranslateY);\n        tmpTranslate = {\n          x: _nextTranslateX,\n          y: _nextTranslateY\n        };\n      }\n    },\n    onRelease: function onRelease() {\n      cancelLongPressHandle();\n\n      if (isDoubleTapPerformed) {\n        isDoubleTapPerformed = false;\n      }\n\n      if (tmpScale > 0) {\n        if (tmpScale < initialScale || tmpScale > SCALE_MAX) {\n          tmpScale = tmpScale < initialScale ? initialScale : SCALE_MAX;\n          Animated.timing(scaleValue, {\n            toValue: tmpScale,\n            duration: 100,\n            useNativeDriver: true\n          }).start();\n        }\n\n        currentScale = tmpScale;\n        tmpScale = 0;\n      }\n\n      if (tmpTranslate) {\n        var _tmpTranslate = tmpTranslate,\n            x = _tmpTranslate.x,\n            y = _tmpTranslate.y;\n\n        var _getBounds5 = getBounds(currentScale),\n            _getBounds6 = _slicedToArray(_getBounds5, 4),\n            topBound = _getBounds6[0],\n            leftBound = _getBounds6[1],\n            bottomBound = _getBounds6[2],\n            rightBound = _getBounds6[3];\n\n        var nextTranslateX = x;\n        var nextTranslateY = y;\n\n        if (!fitsScreenByWidth()) {\n          if (nextTranslateX > leftBound) {\n            nextTranslateX = leftBound;\n          } else if (nextTranslateX < rightBound) {\n            nextTranslateX = rightBound;\n          }\n        }\n\n        if (!fitsScreenByHeight()) {\n          if (nextTranslateY > topBound) {\n            nextTranslateY = topBound;\n          } else if (nextTranslateY < bottomBound) {\n            nextTranslateY = bottomBound;\n          }\n        }\n\n        Animated.parallel([Animated.timing(translateValue.x, {\n          toValue: nextTranslateX,\n          duration: 100,\n          useNativeDriver: true\n        }), Animated.timing(translateValue.y, {\n          toValue: nextTranslateY,\n          duration: 100,\n          useNativeDriver: true\n        })]).start();\n        currentTranslate = {\n          x: nextTranslateX,\n          y: nextTranslateY\n        };\n        tmpTranslate = null;\n      }\n    }\n  };\n  var panResponder = useMemo(function () {\n    return createPanResponder(handlers);\n  }, [handlers]);\n  return [panResponder.panHandlers, scaleValue, translateValue];\n};\n\nexport default usePanResponder;","map":{"version":3,"sources":["X:/SIH/Meri-Sadak/node_modules/react-native-image-viewing/dist/hooks/usePanResponder.js"],"names":["useMemo","useEffect","createPanResponder","getDistanceBetweenTouches","getImageTranslate","getImageDimensionsByTranslate","SCREEN","Dimensions","get","SCREEN_WIDTH","width","SCREEN_HEIGHT","height","MIN_DIMENSION","Math","min","SCALE_MAX","DOUBLE_TAP_DELAY","OUT_BOUND_MULTIPLIER","usePanResponder","initialScale","initialTranslate","onZoom","doubleTapToZoomEnabled","onLongPress","delayLongPress","numberInitialTouches","initialTouches","currentScale","currentTranslate","tmpScale","tmpTranslate","isDoubleTapPerformed","lastTapTS","longPressHandlerRef","meaningfulShift","scaleValue","Animated","Value","translateValue","ValueXY","imageDimensions","getBounds","scale","scaledImageDimensions","translateDelta","left","x","right","top","y","bottom","getTranslateInBounds","translate","inBoundTranslate","topBound","leftBound","bottomBound","rightBound","fitsScreenByWidth","fitsScreenByHeight","addListener","value","removeAllListeners","cancelLongPressHandle","clearTimeout","handlers","onGrant","_","gestureState","numberActiveTouches","setTimeout","onStart","event","nativeEvent","touches","tapTS","Date","now","Boolean","isScaled","touchX","pageX","touchY","pageY","targetScale","nextScale","nextTranslate","parallel","timing","toValue","duration","useNativeDriver","stopTogether","start","onMove","dx","dy","abs","isTapGesture","isPinchGesture","initialDistance","currentDistance","k","nextTranslateX","nextTranslateY","setValue","onRelease","panResponder","panHandlers"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) JOB TODAY S.A. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useMemo, useEffect } from \"react\";\nimport { Animated, Dimensions, } from \"react-native\";\nimport { createPanResponder, getDistanceBetweenTouches, getImageTranslate, getImageDimensionsByTranslate, } from \"../utils\";\nconst SCREEN = Dimensions.get(\"window\");\nconst SCREEN_WIDTH = SCREEN.width;\nconst SCREEN_HEIGHT = SCREEN.height;\nconst MIN_DIMENSION = Math.min(SCREEN_WIDTH, SCREEN_HEIGHT);\nconst SCALE_MAX = 2;\nconst DOUBLE_TAP_DELAY = 300;\nconst OUT_BOUND_MULTIPLIER = 0.75;\nconst usePanResponder = ({ initialScale, initialTranslate, onZoom, doubleTapToZoomEnabled, onLongPress, delayLongPress, }) => {\n    let numberInitialTouches = 1;\n    let initialTouches = [];\n    let currentScale = initialScale;\n    let currentTranslate = initialTranslate;\n    let tmpScale = 0;\n    let tmpTranslate = null;\n    let isDoubleTapPerformed = false;\n    let lastTapTS = null;\n    let longPressHandlerRef = null;\n    const meaningfulShift = MIN_DIMENSION * 0.01;\n    const scaleValue = new Animated.Value(initialScale);\n    const translateValue = new Animated.ValueXY(initialTranslate);\n    const imageDimensions = getImageDimensionsByTranslate(initialTranslate, SCREEN);\n    const getBounds = (scale) => {\n        const scaledImageDimensions = {\n            width: imageDimensions.width * scale,\n            height: imageDimensions.height * scale,\n        };\n        const translateDelta = getImageTranslate(scaledImageDimensions, SCREEN);\n        const left = initialTranslate.x - translateDelta.x;\n        const right = left - (scaledImageDimensions.width - SCREEN.width);\n        const top = initialTranslate.y - translateDelta.y;\n        const bottom = top - (scaledImageDimensions.height - SCREEN.height);\n        return [top, left, bottom, right];\n    };\n    const getTranslateInBounds = (translate, scale) => {\n        const inBoundTranslate = { x: translate.x, y: translate.y };\n        const [topBound, leftBound, bottomBound, rightBound] = getBounds(scale);\n        if (translate.x > leftBound) {\n            inBoundTranslate.x = leftBound;\n        }\n        else if (translate.x < rightBound) {\n            inBoundTranslate.x = rightBound;\n        }\n        if (translate.y > topBound) {\n            inBoundTranslate.y = topBound;\n        }\n        else if (translate.y < bottomBound) {\n            inBoundTranslate.y = bottomBound;\n        }\n        return inBoundTranslate;\n    };\n    const fitsScreenByWidth = () => imageDimensions.width * currentScale < SCREEN_WIDTH;\n    const fitsScreenByHeight = () => imageDimensions.height * currentScale < SCREEN_HEIGHT;\n    useEffect(() => {\n        scaleValue.addListener(({ value }) => {\n            if (typeof onZoom === \"function\") {\n                onZoom(value !== initialScale);\n            }\n        });\n        return () => scaleValue.removeAllListeners();\n    });\n    const cancelLongPressHandle = () => {\n        longPressHandlerRef && clearTimeout(longPressHandlerRef);\n    };\n    const handlers = {\n        onGrant: (_, gestureState) => {\n            numberInitialTouches = gestureState.numberActiveTouches;\n            if (gestureState.numberActiveTouches > 1)\n                return;\n            longPressHandlerRef = setTimeout(onLongPress, delayLongPress);\n        },\n        onStart: (event, gestureState) => {\n            initialTouches = event.nativeEvent.touches;\n            numberInitialTouches = gestureState.numberActiveTouches;\n            if (gestureState.numberActiveTouches > 1)\n                return;\n            const tapTS = Date.now();\n            // Handle double tap event by calculating diff between first and second taps timestamps\n            isDoubleTapPerformed = Boolean(lastTapTS && tapTS - lastTapTS < DOUBLE_TAP_DELAY);\n            if (doubleTapToZoomEnabled && isDoubleTapPerformed) {\n                const isScaled = currentTranslate.x !== initialTranslate.x; // currentScale !== initialScale;\n                const { pageX: touchX, pageY: touchY } = event.nativeEvent.touches[0];\n                const targetScale = SCALE_MAX;\n                const nextScale = isScaled ? initialScale : targetScale;\n                const nextTranslate = isScaled\n                    ? initialTranslate\n                    : getTranslateInBounds({\n                        x: initialTranslate.x +\n                            (SCREEN_WIDTH / 2 - touchX) * (targetScale / currentScale),\n                        y: initialTranslate.y +\n                            (SCREEN_HEIGHT / 2 - touchY) * (targetScale / currentScale),\n                    }, targetScale);\n                onZoom(!isScaled);\n                Animated.parallel([\n                    Animated.timing(translateValue.x, {\n                        toValue: nextTranslate.x,\n                        duration: 300,\n                        useNativeDriver: true,\n                    }),\n                    Animated.timing(translateValue.y, {\n                        toValue: nextTranslate.y,\n                        duration: 300,\n                        useNativeDriver: true,\n                    }),\n                    Animated.timing(scaleValue, {\n                        toValue: nextScale,\n                        duration: 300,\n                        useNativeDriver: true,\n                    }),\n                ], { stopTogether: false }).start(() => {\n                    currentScale = nextScale;\n                    currentTranslate = nextTranslate;\n                });\n                lastTapTS = null;\n            }\n            else {\n                lastTapTS = Date.now();\n            }\n        },\n        onMove: (event, gestureState) => {\n            const { dx, dy } = gestureState;\n            if (Math.abs(dx) >= meaningfulShift || Math.abs(dy) >= meaningfulShift) {\n                cancelLongPressHandle();\n            }\n            // Don't need to handle move because double tap in progress (was handled in onStart)\n            if (doubleTapToZoomEnabled && isDoubleTapPerformed) {\n                cancelLongPressHandle();\n                return;\n            }\n            if (numberInitialTouches === 1 &&\n                gestureState.numberActiveTouches === 2) {\n                numberInitialTouches = 2;\n                initialTouches = event.nativeEvent.touches;\n            }\n            const isTapGesture = numberInitialTouches == 1 && gestureState.numberActiveTouches === 1;\n            const isPinchGesture = numberInitialTouches === 2 && gestureState.numberActiveTouches === 2;\n            if (isPinchGesture) {\n                cancelLongPressHandle();\n                const initialDistance = getDistanceBetweenTouches(initialTouches);\n                const currentDistance = getDistanceBetweenTouches(event.nativeEvent.touches);\n                let nextScale = (currentDistance / initialDistance) * currentScale;\n                /**\n                 * In case image is scaling smaller than initial size ->\n                 * slow down this transition by applying OUT_BOUND_MULTIPLIER\n                 */\n                if (nextScale < initialScale) {\n                    nextScale =\n                        nextScale + (initialScale - nextScale) * OUT_BOUND_MULTIPLIER;\n                }\n                /**\n                 * In case image is scaling down -> move it in direction of initial position\n                 */\n                if (currentScale > initialScale && currentScale > nextScale) {\n                    const k = (currentScale - initialScale) / (currentScale - nextScale);\n                    const nextTranslateX = nextScale < initialScale\n                        ? initialTranslate.x\n                        : currentTranslate.x -\n                            (currentTranslate.x - initialTranslate.x) / k;\n                    const nextTranslateY = nextScale < initialScale\n                        ? initialTranslate.y\n                        : currentTranslate.y -\n                            (currentTranslate.y - initialTranslate.y) / k;\n                    translateValue.x.setValue(nextTranslateX);\n                    translateValue.y.setValue(nextTranslateY);\n                    tmpTranslate = { x: nextTranslateX, y: nextTranslateY };\n                }\n                scaleValue.setValue(nextScale);\n                tmpScale = nextScale;\n            }\n            if (isTapGesture && currentScale > initialScale) {\n                const { x, y } = currentTranslate;\n                const { dx, dy } = gestureState;\n                const [topBound, leftBound, bottomBound, rightBound] = getBounds(currentScale);\n                let nextTranslateX = x + dx;\n                let nextTranslateY = y + dy;\n                if (nextTranslateX > leftBound) {\n                    nextTranslateX =\n                        nextTranslateX -\n                            (nextTranslateX - leftBound) * OUT_BOUND_MULTIPLIER;\n                }\n                if (nextTranslateX < rightBound) {\n                    nextTranslateX =\n                        nextTranslateX -\n                            (nextTranslateX - rightBound) * OUT_BOUND_MULTIPLIER;\n                }\n                if (nextTranslateY > topBound) {\n                    nextTranslateY =\n                        nextTranslateY - (nextTranslateY - topBound) * OUT_BOUND_MULTIPLIER;\n                }\n                if (nextTranslateY < bottomBound) {\n                    nextTranslateY =\n                        nextTranslateY -\n                            (nextTranslateY - bottomBound) * OUT_BOUND_MULTIPLIER;\n                }\n                if (fitsScreenByWidth()) {\n                    nextTranslateX = x;\n                }\n                if (fitsScreenByHeight()) {\n                    nextTranslateY = y;\n                }\n                translateValue.x.setValue(nextTranslateX);\n                translateValue.y.setValue(nextTranslateY);\n                tmpTranslate = { x: nextTranslateX, y: nextTranslateY };\n            }\n        },\n        onRelease: () => {\n            cancelLongPressHandle();\n            if (isDoubleTapPerformed) {\n                isDoubleTapPerformed = false;\n            }\n            if (tmpScale > 0) {\n                if (tmpScale < initialScale || tmpScale > SCALE_MAX) {\n                    tmpScale = tmpScale < initialScale ? initialScale : SCALE_MAX;\n                    Animated.timing(scaleValue, {\n                        toValue: tmpScale,\n                        duration: 100,\n                        useNativeDriver: true,\n                    }).start();\n                }\n                currentScale = tmpScale;\n                tmpScale = 0;\n            }\n            if (tmpTranslate) {\n                const { x, y } = tmpTranslate;\n                const [topBound, leftBound, bottomBound, rightBound] = getBounds(currentScale);\n                let nextTranslateX = x;\n                let nextTranslateY = y;\n                if (!fitsScreenByWidth()) {\n                    if (nextTranslateX > leftBound) {\n                        nextTranslateX = leftBound;\n                    }\n                    else if (nextTranslateX < rightBound) {\n                        nextTranslateX = rightBound;\n                    }\n                }\n                if (!fitsScreenByHeight()) {\n                    if (nextTranslateY > topBound) {\n                        nextTranslateY = topBound;\n                    }\n                    else if (nextTranslateY < bottomBound) {\n                        nextTranslateY = bottomBound;\n                    }\n                }\n                Animated.parallel([\n                    Animated.timing(translateValue.x, {\n                        toValue: nextTranslateX,\n                        duration: 100,\n                        useNativeDriver: true,\n                    }),\n                    Animated.timing(translateValue.y, {\n                        toValue: nextTranslateY,\n                        duration: 100,\n                        useNativeDriver: true,\n                    }),\n                ]).start();\n                currentTranslate = { x: nextTranslateX, y: nextTranslateY };\n                tmpTranslate = null;\n            }\n        },\n    };\n    const panResponder = useMemo(() => createPanResponder(handlers), [handlers]);\n    return [panResponder.panHandlers, scaleValue, translateValue];\n};\nexport default usePanResponder;\n"]},"metadata":{},"sourceType":"module"}